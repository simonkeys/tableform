# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/core.ipynb.

# %% auto 0
__all__ = ['get_or_last', 'is_astropy_quantity', 'TableForm']

# %% ../nbs/core.ipynb 2
import warnings
import sys
from numbers import Integral

# %% ../nbs/core.ipynb 3
def get_or_last(l, i):
    try: return l[i]
    except:
        try: return l[-1]
        except: return l

# %% ../nbs/core.ipynb 4
def is_astropy_quantity(a):
    return str(a.__class__) == "<class 'astropy.units.quantity.Quantity'>"

# %% ../nbs/core.ipynb 5
class TableForm:
    def __init__(self, a=None, fmt='.2f', border_color="Gray", width="auto", edgeitems=3, font_size=12, padding=2):
        self.a = a
        self.fmt = fmt
        if border_color == 'auto':
            border_color = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']
        elif isinstance(border_color, str):
            border_color = [border_color]
        self.border_color = border_color
        self.width = width
        self.font_size = font_size
        self.padding = padding
        self.edgeitems = edgeitems

    def table_tag(self, content, depth, brackets=False):
        return (
            (f'<div style="font-size:{self.font_size}px">{self.table_caption()}</div>' if depth == 0 else '') + 
            '<table style="display:inline-table; text-align: center;' +
            self.font_style() +
            self.table_width(depth) +
            self.table_border(depth) +
            (self.table_brackets() if brackets else "") +
            self.table_padding() +
            self.table_margin(depth) +
            '">' +
            content +
            '</table>'
        )

    def table_caption(self):
        caption = self.a.__class__.__name__
        try: caption += f' {tuple(self.a.shape)} {self.a.dtype}'
        except: pass
        return caption
            
    def table_padding(self):
        return f'padding: {self.padding}px;'
        
    def font_style(self):
        return f'font-size:{self.font_size}px;'
        
    def table_width(self, depth):
        return f'width: {get_or_last(self.width, depth)};'

    def table_border(self, depth):
        return f'border: 1.5px solid {self.border_color[depth % len(self.border_color)]};'

    def table_brackets(self):
        return (
            "border-top-style: none;" +  
            "border-bottom-style: none;" +
            "border-radius: 5px;" +
            "border-spacing: 0px;" +
            "border-collapse:separate;" 
        )

    def table_margin(self, depth):
        return f'margin: 0px {"0" if depth == 0 else "auto"};'
    
    def caption_tag(self, content):
        return f'<caption style="white-space: nowrap">{content}</caption>'
    
    def td_tag(self, content):
        return f'<td style="padding: {self.padding}px; text-align: center;">{content}</td>'
    
    def tr_tag(self, content):
        return f'<tr style="padding: 0; margin: 0">{content}</tr>'
    
    def abbreviate(self, a, symbol='…'):
        try: # For some reason numpy masked arrays throw error here, otherwise wouldn't need try block
            if a[0] in ['…', '︙']: return a
        except ValueError: pass
        l = self.edgeitems
        if l and len(a) > 2 * l + 1:
            head = a[:l]
            tail = a[-l:]
            try: 
                if len(a[l - 1]) <= 2 * l + 1:
                    ellipses = [symbol] * len(a[l - 1])
                else:
                    ellipses = [symbol] * l + ["⋱"] + [symbol] * l
            except: ellipses = symbol
            return [*head, ellipses, *tail]
        return a
    
    def make_entry(self, d, depth=0):
        with warnings.catch_warnings():
            warnings.simplefilter('ignore')
            try:
                if d == '⋱': return d
                if set(d) <= {'…', '⋱'}: return '…'
            except: pass
            try: return self.make_table(d, depth+1)
            except:
                if isinstance(d, Integral): return d
                try: return format(d, self.fmt)
                except: return d
    
    def make_row(self, a, depth=0):
        if isinstance(a, str): raise TypeError
        a = self.abbreviate(a, '…')
        return self.tr_tag(''.join(self.td_tag(self.make_entry(entry, depth)) for entry in a))
    
    def make_rows(self, a, depth=0):
        a = self.abbreviate(a, "︙")
        return "\n".join(self.make_row(row, depth) for row in a)
    
    def make_table(self, a, depth=0):
        if isinstance(a, str): raise TypeError
        try:
            return self.table_tag(self.make_rows(a, depth), depth, brackets=False)
        except:
            return self.table_tag(self.make_row(a, depth), depth, brackets=True) 
        
    def _repr_html_(self):
        if is_astropy_quantity(self.a):
            return self.make_entry(self.a.value, depth=-1) + "&nbsp;" +self.a.unit.to_string('unicode')
        return self.make_entry(self.a, depth=-1)

    @classmethod
    def register(cls, *types):
        """Register `types` in IPython to display using `TableForm`."""
        try: 
            formatter = get_ipython().display_formatter.formatters['text/html']
            for _type in types: formatter.for_type(_type, lambda o: cls(o)._repr_html_())
        except NameError: pass

# %% ../nbs/core.ipynb 13
try: TableForm.register(sys.modules['numpy'].ndarray)
except KeyError: pass
